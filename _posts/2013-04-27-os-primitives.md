---
layout: default
title: 谈操作系统的“原语”
published: false
---


有一次 Cornell 的博士生操作系统考试出了这么一道题：一条河的两边各有5只猴子要过河。可是河上只有一根绳子，猴子需要攀着绳子过河。如果两只猴子在绳子中间遇上了，就会掉进河里。请你使用 semaphore 写出一个程序，让这些猴子都可以安全过河。

我的答案是：让这些猴子先去“拿号”，被叫到号码的猴子挨个过河。可是没想到这么喜欢排队的美国人，居然觉得我的答案是错的，就因为我没用 semaphore。

当然我是打个比方而已。我的做法其实是这样，每个猴子需要过河的时候，把一个叫做“过河”的函数挂到一个叫做“绳子”的队列里面去。绳子是另外一个“进程”，这个进程会安排被挂在上面的猴子按照“先来后到”的顺序依次过河。

操作系统的课程和书籍往往有很多类似的“同步”问题。对于这些问题，往往有人给你一个“标准答案”，却从来不告诉你这标准答案是怎么想出来的。谁也不知道如何才能“系统的”（systematically），按部就班的得到这些问题的答案。这些问题的“标准答案”里面往往含有一些“聪明技巧”，貌似天上掉下来的。然而你却很难相信它们是正确的，证明这些答案的正确性到现在还是研究性质的问题。所以有时候你绞尽脑汁用 semaphore 这样的东西写出来一个程序，试了好多个例子貌似都是对的，结果最后实际运行的时候就出问题。

我觉得这里的问题在于，这些操作系统的“原语”（比如 semaphore） 本来是被“发明”出来解决某个“特定”的问题，而并不是本质上“通用”的东西。对于当时要解决的那一个问题，它也许是很有效的。可是接下来它就被滥用了，被用在了设计者没有考虑过的地方。当然，你就遇到各种麻烦的问题，比如“竞争”，“死锁”。试图使用你的聪明才智利用它们来解决问题，只不过是一些 workaround 而已。其实很多专家级的人物用这些东西的时候心里都在打鼓，不知道到时候会不会出问题。这样的现象，往往意味着你使用了错误的工具。

这就像很多人在 C 程序里写 macro 用来代替“重复的代码”。在某个程序里这个 macro 也许是有效的。可是接下来它就被滥用了。人们看不到，其实被这个 macro “组合”起来的那些操作如果被分开来用，会让程序更加直接的达到目的。然而写出了这个 macro 之后，有人就开始错误的认为这些被它所压缩在一起的操作是一个“原语”，从而不假思索的开始“重用”它。这个错误跟 semaphore 被到处滥用的现象本质是一样的。
