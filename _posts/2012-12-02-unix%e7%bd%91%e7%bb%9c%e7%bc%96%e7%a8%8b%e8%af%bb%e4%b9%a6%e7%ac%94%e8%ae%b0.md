---
title: UNIX网络编程读书笔记
author: admin
layout: post
permalink: /?p=582
categories:
  - 未分类
---
# 

        UNIX网络编程却是一本好书，目前已经出到了第三版，我一直觉得这类书，适合放到书架上，需要的时候查一查，实践加上理论理解更加深刻，若是单单看书，很容易便会忘记，而且对相关的理论理解也不够深刻。废话不多说了，这是本非常经典的书，我这里只做一些简单的笔记，如果你正在写c的网络程序，十分建议你读一下！

***第 3章，套接字编程简介***

1，“值，结果”模型

从内核到进程传递套接口地址结构有4个函数，accept，recvfrom，getsockname和getpeername，这4个函数的两个参数是：指向套接口地址结构的指针和指向表示结构大小的整数的指针。如



    struct socketaddr_un cll;
    socklen_t len;
    len=sizeof(cll);
    getpeername(unixfd,(SA*)&cli,&len);

为何将结构大小由整数改为指向整数的指针呢？这是因为：当函数被调用时，结构大小是一个值（此值告诉内核该结构的大小，使内核在写此结构时不至于越界），当函数返回时，结构大小又是一个结果（塔告诉进程内核在此结构中确切存储了多少信息），这种参数类型叫值-结果参数。

我之前写程序时，没有len=sizeof(cll)这一句，以为内核会自动填充指针指的内容，最后导致的结果是接受不到指向套接口地址结构。

***第 4章，基本TCP套接字编程***

1，服务器fork一个进程处理一个连接时，子进程为复制父进程的全部内容。所以子进程需要关闭listenfd，父进程需要关闭connfd。

***第 5章，TCP客户-服务器程序例子***

1，服务器端的子进程结束后变成僵尸进程，父进程需要捕捉信号SIGCHLD来处理。同时信号处理程序调用waitpid，之所以不使用wait函数，是因为unix信号是不排队的，waitpid第三个参数能设置非阻塞。

2，服务器进程终止时，客户不知道。客户的tcp虽然被通知了，但是客户本身由于正阻塞于等待用户输入而未接收到此通知。我们可以使用select和poll来处理这种情况，塔等待多个多个描述符中得任一个准备好而不是阻塞于单个描述字。

同时在本段内容，作者详细分析了主机进程终止，主机崩溃和主机关机等等多种情况下，主机端和客户端tcp套接字状态的变化状态，使我们对网络细节有了全方位的了解，很值得一读。

3，主机崩溃后重启。只要客户端不向发服务器发数据，客户端就不知道，然而此时服务器端已经丢失了所以连接的信息。所以为了使客户端尽早意识到这个事实，在7.5节作者将利用套接口选项SO_KEEPALIVE.

4，传输的内容。客户端和服务器端传输文本没有问题，因为文本是字符串，每个字符都是一个字节。但是如果传输二进制数据，如结构体，就会出现很多问题。如，大小端问题，不同机器c数据类型可能不一样还有字节对齐问题。解决这个问题有两种方法，一是转化成字符串传输，也是基于两个机器上有相同的字符集。二是显式定义所支持数据类型的二进制格式，在客户和服务器之间以此格式传递所有数据。



***第 26章，线程***

1，给新线程传参数

    connfd=accept(listenfd,cliaddr,&len);
    pthread_create(&tid,NULL,&doit,&connfd);

会出现问题，因为pthread_create传递是一个指针，当线程还有解引用之前，accept又返回一次，把之前的connfd覆盖了，就会出现问题。所以应该这样写

    iptr=(int*)malloc(sizeof(int));
    *iptr=accept(listenfd,cliaddr,&len);
    pthread_create(&tid,NULL,&doit,iptr);